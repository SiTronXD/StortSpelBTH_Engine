#version 460

#define FREQ_PER_FRAME 0

layout (local_size_x = 32) in;

// Uniform buffer
layout(set = FREQ_PER_FRAME, binding = 0) uniform CameraBuffer
{
    mat4 projection;
    mat4 view;
    vec4 worldPos;
} cameraBuffer;

// Storage buffer
struct ParticleInfoData
{
    mat4 transform;
    vec4 life;  // vec4(currentLifeTime, maxLifeTime, 0.0f, 0.0f)
    vec2 startSize;
    vec2 endSize;
    vec4 startColor;
    vec4 endColor;
    vec4 startVelocity;
    vec4 currentVelocity;
    vec4 acceleration;
};
layout(std140, set = FREQ_PER_FRAME, binding = 1) buffer ParticleInfosBuffer
{
    ParticleInfoData infos[];
} particles;

// Uniform buffer
layout(set = FREQ_PER_FRAME, binding = 2) uniform ParticleBufferData
{
    vec2 padding;
    float deltaTime;
    uint numParticles;
} globalParticleBuffer;

uint wang_hash(uint seed)
{
    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));
    seed *= uint(9);
    seed = seed ^ (seed >> 4);
    seed *= uint(0x27d4eb2d);
    seed = seed ^ (seed >> 15);

    return seed;
}

float randomFloat(float state)
{
    return float(wang_hash(uint(state))) / 4294967296.0;
}

vec3 randomVec(vec3 state)
{
    return vec3(
        randomFloat(state.x + state.y * 1024.0 + state.z * 128.0),
        randomFloat(state.x * 512.0 + state.y * 2048.0 + state.z * 256.0),
        randomFloat(state.x * 1024.0 + state.y * 4096.0 + state.z * 512.0)
    ) * 2.0f - vec3(1.0f);
}

void main()
{
    // Avoid computing particles that are outside the range
    if(gl_GlobalInvocationID.x >= globalParticleBuffer.numParticles)
    {
        return;
    }

    // Get info
    ParticleInfoData particle = 
        particles.infos[gl_GlobalInvocationID.x];
    vec3 position = particle.transform[3].xyz;
    float deltaTime = globalParticleBuffer.deltaTime;

    // Apply position
    particle.currentVelocity.xyz += particle.acceleration.xyz * deltaTime;
    position.xyz += particle.currentVelocity.xyz * deltaTime;

    // Reset life
    particle.life.x += deltaTime;
    if(particle.life.x >= particle.life.y)
    {
        particle.life.x = mod(particle.life.x, particle.life.y);
        
        particle.currentVelocity.xyz = 
            particle.startVelocity.xyz + 
            randomVec(vec3(gl_GlobalInvocationID.x));
        position = vec3(0.0f);
    }

    // Scale
    vec2 currentScale = mix(
        particle.startSize, 
        particle.endSize,
        clamp(particle.life.x / particle.life.y, 0.0f, 1.0f)
    );

    // Update direction
    vec3 forward = normalize(cameraBuffer.worldPos.xyz - position);
    vec3 right = -normalize(cross(forward, vec3(0.0f, 1.0f, 0.0f)));
    vec3 up = -cross(right, forward);

    // Update transform
    particle.transform = mat4(
        vec4(   right,  0.0f) * currentScale.x,
        vec4(      up,  0.0f) * currentScale.y,
        vec4( forward,  0.0f),
        vec4(position,  1.0f)
    );

    // Update new data
    particles.infos[gl_GlobalInvocationID.x] = particle;
}